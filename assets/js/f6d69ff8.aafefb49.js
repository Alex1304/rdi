"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[382],{1916(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"intro","title":"Introduction to RDI","description":"What is RDI?","source":"@site/../docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/rdi/docs/intro","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Alex1304","lastUpdatedAt":1766883864000,"frontMatter":{"id":"intro","title":"Introduction to RDI","sidebar_label":"Introduction"},"sidebar":"docs","next":{"title":"Getting Started","permalink":"/rdi/docs/getting-started"}}');var a=t(6070),r=t(8193);const o={id:"intro",title:"Introduction to RDI",sidebar_label:"Introduction"},s=void 0,c={},l=[{value:"What is RDI?",id:"what-is-rdi",level:2},{value:"Dependency injection in a nutshell",id:"dependency-injection-in-a-nutshell",level:2},{value:"Overview of how RDI works",id:"overview-of-how-rdi-works",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("img",{align:"right",src:"/rdi/img/logo.png",width:"20%"}),"\n",(0,a.jsx)(n.h2,{id:"what-is-rdi",children:"What is RDI?"}),"\n",(0,a.jsxs)(n.p,{children:["RDI stands for Reactive Dependency Injection. It is a library allowing to manage the instantiation of beans, services, and any kind of Java object living in your application simply by defining their dependencies. The specificity of RDI is that it fully supports the reactive programming paradigm, as defined by the ",(0,a.jsx)(n.a,{href:"https://www.reactive-streams.org/",children:"Reactive Streams specification"}),", allowing to make efficient and non-blocking applications with backpressure handling."]}),"\n",(0,a.jsx)(n.h2,{id:"dependency-injection-in-a-nutshell",children:"Dependency injection in a nutshell"}),"\n",(0,a.jsxs)(n.p,{children:["The principle of dependency injection isn't new. The way it works is similar to ",(0,a.jsx)(n.a,{href:"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans",children:"Spring's IoC Container"}),", as well as some other frameworks featuring a such mechanism like Quarkus or JSF. Unlike these examples however, RDI isn't a full-fledged framework, but rather a lightweight library 100% focused on dependency injection."]}),"\n",(0,a.jsx)(n.p,{children:"To illustrate how dependency injection operates, consider the following basic classes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public class A {\n    private final B b;\n    public A(B b) {\n        this.b = b;\n    }\n}\n\npublic class B {\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can see that A needs an instance of B in the constructor. Normally you would do something along these lines:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"B b = new B();\nA a = new A(b);\n// use A to do stuff\n"})}),"\n",(0,a.jsx)(n.p,{children:"We are here instantiating A and B in the same place, but you can imagine B is instantiated elsewhere in the application. As a result, it can turn quite difficult to keep track of the lifecycle and the scope of each object, especially in large apps. Dependency injection naturally comes up as a solution when you want to decouple the initialization part from the core logic of your objects."}),"\n",(0,a.jsx)(n.p,{children:"With a dependency injection library, getting an instance of A would be like this:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"A a = container.get(A.class);\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"container"})," here would be an object that is aware of the existence of A and B class, as well as the details about constructor arguments. With all that information, all you need to do is to ask the container \"Hey, can I get an instance of A please?\" and it will execute. This approach has many advantages other than centralizing instantiation of objects into one place. You can for example tell the container whether it should always return the same instance of A or instantiate a new one each time the object is requested. If it should return the same instance, that's something you would normally do with a singleton pattern, which can cause issues especially in a case of concurrent access by multiple threads. A container would be able to handle that thread safety aspect for you, preferably in a lock-free manner so that it doesn't degrade the performances of your application."]}),"\n",(0,a.jsx)(n.h2,{id:"overview-of-how-rdi-works",children:"Overview of how RDI works"}),"\n",(0,a.jsxs)(n.p,{children:["The way RDI implements this principle does not differ much from what already exists in terms of dependency injection. As such, RDI comes with the concept of ",(0,a.jsx)(n.em,{children:"container"}),", the main object that will manage the initialization of all objects in your app and that will take care of injecting the necessary dependencies. Dependencies may be specified in constructor arguments, in setter arguments or in factory methods. For the previous example, configuring a container with RDI would look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Define service references as constants\npublic static final ServiceReference<A> A_REF = ServiceReference.ofType(A.class);\npublic static final ServiceReference<B> B_REF = ServiceReference.ofType(B.class);\n\n// Create the config\n// We register both A and B, and specify that we should inject B in the constructor of A\nRdiConfig config = RdiConfig.builder()\n        .registerService(ServiceDescriptor.builder(A_REF)\n                .setFactoryMethod(FactoryMethod.constructor(Injectable.ref(B_REF)))\n                .build())\n        .registerService(ServiceDescriptor.standalone(B_REF))\n        .build();\n// Create the container by passing the config\nRdiServiceContainer container = RdiServiceContainer.create(config);\n// Get an instance of A. The dependency injection will operate and A will be ready to use!\nA a = container.getService(A_REF).block(); // Remember RDI is reactive. Here we block until A is fully created.\n"})}),"\n",(0,a.jsx)(n.p,{children:"Here is some quick explanation of this code:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Objects managed by the RDI container are called ",(0,a.jsx)(n.strong,{children:"services"}),". Services are referred to by their ",(0,a.jsx)(n.strong,{children:"reference"}),", defining their type and optionally their name (if you want to define more than one service of the same type you may give them unique names, by default it uses the name of the class)."]}),"\n",(0,a.jsxs)(n.li,{children:["Before creating the container, we need a way to tell it what are the different services available and how to inject the dependencies they may have. This is done via the ",(0,a.jsx)(n.code,{children:"RdiConfig"})," object, where you register a ",(0,a.jsx)(n.strong,{children:"descriptor"})," for each service defining the dependencies to inject."]}),"\n",(0,a.jsxs)(n.li,{children:["You then pass the config to create the ",(0,a.jsx)(n.strong,{children:"container"}),". Dependency resolution and circular dependency checks are performed at creation time."]}),"\n",(0,a.jsxs)(n.li,{children:["Once your container is ready, you may call ",(0,a.jsx)(n.code,{children:"getService"})," with the reference of the service you want, and it will prepare the instance with all the dependencies injected for you. The particularity here is that it doesn't return the instance directly due to the reactive nature of RDI. To get the instance you must ",(0,a.jsx)(n.strong,{children:"subscribe"})," to the reactive stream returned by ",(0,a.jsx)(n.code,{children:"getService"})," (in this case, it is a ",(0,a.jsx)(n.code,{children:"Mono"})," from ",(0,a.jsx)(n.a,{href:"https://projectreactor.io",children:"Reactor Core"}),", a popular implementation of the ",(0,a.jsx)(n.a,{href:"https://www.reactive-streams.org/",children:"Reactive Streams specification"}),"). Subscribing is done either via ",(0,a.jsx)(n.code,{children:".subscribe(Consumer)"})," (which does not block and invokes the consumer when the object is ready), or via ",(0,a.jsx)(n.code,{children:".block()"})," (blocks the program and wait until the object is ready)."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In the above example we only instantiated objects via public constructors. The most interesting part of RDI is when a service needs to be instantiated with a factory method returning a publisher of it. Let's enrich the ",(0,a.jsx)(n.code,{children:"B"})," class with the following:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"public class B {\n    private B() {}\n\n    public static Mono<B> create() {\n        return Mono.fromCallable(B::new);\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"create"})," method is a static factory that returns a publisher of ",(0,a.jsx)(n.code,{children:"B"})," (in this case a ",(0,a.jsx)(n.code,{children:"Mono"}),", but can be anything implementing ",(0,a.jsx)(n.code,{children:"org.reactivestreams.Publisher"}),"). You can imagine that the factory method performs some webservice call or other reactive task before creating the actual instance of B. RDI is able to handle this kind of factory out of the box. The ",(0,a.jsx)(n.code,{children:"RdiConfig"})," would now look like this:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'RdiConfig config = RdiConfig.builder()\n        .registerService(ServiceDescriptor.builder(A_REF)\n                .setFactoryMethod(FactoryMethod.constructor(Injectable.ref(B_REF)))\n                .build())\n        .registerService(ServiceDescriptor.builder(B_REF)\n                .setFactoryMethod(FactoryMethod.staticFactory("create", Mono.class))\n                .build())\n        .build();\n'})}),"\n",(0,a.jsxs)(n.p,{children:["When requesting an instance of A, the container will first subscribe to the Mono returned by ",(0,a.jsx)(n.code,{children:"B.create()"}),", and then it will inject the obtained B instance into A before returning A. If you have many services like this in you application, RDI may save you a lot of time assembling the reactive chains to get your service instances."]}),"\n",(0,a.jsxs)(n.p,{children:["Since version ",(0,a.jsx)(n.code,{children:"1.1.0"}),", RDI also supports ",(0,a.jsx)(n.a,{href:"/rdi/docs/annotation-based-configuration",children:"annotation-based configuration"})," of the container to save even more time."]}),"\n",(0,a.jsx)(n.p,{children:"Ready to get started? Go ahead and move to next section."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8193(e,n,t){t.d(n,{R:()=>o,x:()=>s});var i=t(758);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);