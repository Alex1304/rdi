"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[844],{2303(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>g});const i=JSON.parse('{"id":"debugging","title":"Debugging","description":"Since RDI uses Reactor Core, it can take advantage from many debugging tools.","source":"@site/../docs/debugging.md","sourceDirName":".","slug":"/debugging","permalink":"/rdi/docs/debugging","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Alex1304","lastUpdatedAt":1596061797000,"frontMatter":{"id":"debugging","title":"Debugging"},"sidebar":"docs","previous":{"title":"Annotation-based Configuration","permalink":"/rdi/docs/annotation-based-configuration"}}');var s=t(6070),a=t(8193);const r={id:"debugging",title:"Debugging"},o=void 0,c={},g=[{value:"Logging",id:"logging",level:2},{value:"Debugging reactive chains",id:"debugging-reactive-chains",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Since RDI uses ",(0,s.jsx)(n.a,{href:"https://projectreactor.io",children:"Reactor Core"}),", it can take advantage from many debugging tools."]}),"\n",(0,s.jsx)(n.h2,{id:"logging",children:"Logging"}),"\n",(0,s.jsxs)(n.p,{children:["Reactor comes with ",(0,s.jsx)(n.code,{children:"reactor.util.Logger"}),", which can abstract the logging solution used by the application, according to what is present in the classpath. If you have an implementation of SLF4J, it will detect it and use it. Otherwise, it will use the native logger present in the JDK."]}),"\n",(0,s.jsx)(n.p,{children:"The default container of RDI logs a few things at the DEBUG level. Currently there are two loggers available:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rdi.resolver.assembly"}),": logs everything that happens when ",(0,s.jsx)(n.strong,{children:"creating the container"}),". It prints information on the dependency graph that is being constructed and the assembly of the reactive chains for each service."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rdi.resolver.subscription"}),": logs everything happening ",(0,s.jsx)(n.strong,{children:"at subscription time"}),". It delivers an output when a service instance has been created, when a dependency has been injected, when a setter is being invoked, when a singleton is being cached, and when the service is fully initialized and ready to be returned."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"debugging-reactive-chains",children:"Debugging reactive chains"}),"\n",(0,s.jsx)(n.p,{children:"Debugging what happens in reactive chain can become a hassle especially if you're a beginner at reactive programming and if you don't know the useful tools."}),"\n",(0,s.jsxs)(n.p,{children:["You can read ",(0,s.jsx)(n.a,{href:"https://spring.io/blog/2019/03/28/reactor-debugging-experience",children:"this article"})," on the Spring blog, which explains well the subtleties of Reactor and what tools exist to achieve debugging."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8193(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(758);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);