"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[176],{2481(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"service-descriptors","title":"Service Descriptors","description":"A service descriptor is what allows to define the dependencies to inject in a specific service. A service descriptor may only apply to a single service reference. If you want to define more than one way to instantiate a class, you are supposed to create as many service references with the same type and with a different name to distinguish them.","source":"@site/../docs/service-descriptors.md","sourceDirName":".","slug":"/service-descriptors","permalink":"/rdi/docs/service-descriptors","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Alex1304","lastUpdatedAt":1596061797000,"frontMatter":{"id":"service-descriptors","title":"Service Descriptors"},"sidebar":"docs","previous":{"title":"Service References","permalink":"/rdi/docs/service-references"},"next":{"title":"The Container","permalink":"/rdi/docs/the-container"}}');var i=t(6070),r=t(8193);const c={id:"service-descriptors",title:"Service Descriptors"},o=void 0,a={},d=[{value:"The <code>Injectable</code> interface",id:"the-injectable-interface",level:2},{value:"Injecting another service",id:"injecting-another-service",level:3},{value:"Injecting values known in advance",id:"injecting-values-known-in-advance",level:3},{value:"Defining dependencies",id:"defining-dependencies",level:2},{value:"Constructor dependencies",id:"constructor-dependencies",level:3},{value:"Static factory dependencies",id:"static-factory-dependencies",level:3},{value:"Setter dependencies",id:"setter-dependencies",level:3},{value:"Considerations regarding method lookup",id:"considerations-regarding-method-lookup",level:2},{value:"Singletons",id:"singletons",level:2},{value:"Circular dependencies",id:"circular-dependencies",level:2},{value:"Convenience methods",id:"convenience-methods",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"service descriptor"})," is what allows to define the dependencies to inject in a specific service. A service descriptor may only apply to a single ",(0,i.jsx)(n.a,{href:"/rdi/docs/service-references",children:"service reference"}),". If you want to define more than one way to instantiate a class, you are supposed to create as many service references with the same type and with a different name to distinguish them."]}),"\n",(0,i.jsxs)(n.h2,{id:"the-injectable-interface",children:["The ",(0,i.jsx)(n.code,{children:"Injectable"})," interface"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Injectable"})," interface is typically used to represent a dependency to inject. It may be a reference to another service, but it can also be a value which is known in advance."]}),"\n",(0,i.jsx)(n.h3,{id:"injecting-another-service",children:"Injecting another service"}),"\n",(0,i.jsxs)(n.p,{children:["This is what you will use most of the time. Injecting another service is done via ",(0,i.jsx)(n.code,{children:"Injectable#ref(ServiceReference)"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"ServiceReference<A> ref = ServiceReference.ofType(A.class);\n\nInjectable toInject = Injectable.ref(ref);\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Important"}),": The other service must be registered in the container as well. Injecting a reference to a service that is not registered will cause an exception upon creating the container."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"injecting-values-known-in-advance",children:"Injecting values known in advance"}),"\n",(0,i.jsxs)(n.p,{children:["If you need to fill a constructor parameter or a setter with a value known in advance, you can use ",(0,i.jsx)(n.code,{children:"Injectable#value(...)"})," (overloads exist for object and primitive types):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"int x = 1304;\n\nInjectable toInject = Injectable.value(x);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"defining-dependencies",children:"Defining dependencies"}),"\n",(0,i.jsx)(n.h3,{id:"constructor-dependencies",children:"Constructor dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["Defining dependencies in a constructor is done with ",(0,i.jsx)(n.code,{children:"FactoryMethod#constructor(Injectable...)"}),". Given the following constructor:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"public class C {\n    // ...\n    public C(D d, int value) {\n        this.d = d;\n        this.value = value;\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The corresponding service descriptor would be the following (",(0,i.jsx)(n.code,{children:"C_REF"})," and ",(0,i.jsx)(n.code,{children:"D_REF"})," being service references to C and D respectively, assuming they are defined as constants):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"ServiceDescriptor descriptor = ServiceDescriptor.builder(C_REF)\n        .setFactoryMethod(FactoryMethod.constructor(Injectable.ref(D_REF), Injectable.value(123456)))\n        .build();\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tip:"})," For better code readability, it is recommended to use static imports for ",(0,i.jsx)(n.code,{children:"FactoryMethod"})," and ",(0,i.jsx)(n.code,{children:"Injectable"})," static methods:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"import static com.github.alex1304.rdi.config.FactoryMethod.*;\nimport static com.github.alex1304.rdi.config.Injectable.*;\n\n// ...\n\nServiceDescriptor descriptor = ServiceDescriptor.builder(C_REF)\n        .setFactoryMethod(constructor(ref(D_REF), value(123456)))\n        .build();\n"})}),"\n",(0,i.jsx)(n.p,{children:"Code examples in this document will make use of static imports going forward."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"static-factory-dependencies",children:"Static factory dependencies"}),"\n",(0,i.jsx)(n.p,{children:"Static factories work the same way as constructors, except that they have a name and a return type. Below is an example static factory and the corresponding service descriptor:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class E {\n    // ...\n    public static E create(F f, long value) {\n        return new E(f, value);\n    }\n}\n\n// ...\nServiceDescriptor descriptor = ServiceDescriptor.builder(E_REF)\n        .setFactoryMethod(staticFactory("create", E.class, ref(F_REF), value(1200L)))\n        .build();\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," Static factories might as well be located in a different class than the service itself, for example in an utility class. In that case, use ",(0,i.jsx)(n.code,{children:"FactoryMethod#externalStaticFactory"})," instead which takes the owner class as first argument, the other arguments are the same as for the regular ",(0,i.jsx)(n.code,{children:"staticFactory"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"setter-dependencies",children:"Setter dependencies"}),"\n",(0,i.jsx)(n.p,{children:"RDI also supports injection via setters. Useful for mutable classes, it works as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class G {\n    // ...\n    public void setH(H h) {\n        this.h = h;\n    }\n    public void setCount(int count) {\n        this.count = count;\n    }\n}\n// ...\nServiceDescriptor descriptor = ServiceDescriptor.builder(G_REF)\n        .addSetterMethod("setH", ref(H_REF))\n        .addSetterMethod("setCount", value(1234))\n        .build();\n'})}),"\n",(0,i.jsx)(n.p,{children:'Unlike constructors and factories, you cannot inject more than 1 dependency per setter, but you can add as many setters as you want. You may even specify the same setter multiple times, useful if the setter performs a "add" operation.'}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," if the return type of the setter is not ",(0,i.jsx)(n.code,{children:"void"}),", which is typically the case for objects that return themselves for chaining purposes, there is an overload that takes the return type as last argument."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"considerations-regarding-method-lookup",children:"Considerations regarding method lookup"}),"\n",(0,i.jsx)(n.p,{children:"Because RDI uses the Method Handles API behind the scenes to find the injection methods, there are a few considerations to take into account in order not to be surprised with some exceptions:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"All injection methods must be public"}),". This is a requirement to always follow, otherwise the ",(0,i.jsx)(n.code,{children:"build()"})," method on ",(0,i.jsx)(n.code,{children:"ServiceDescriptor"})," will throw an exception."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"The injectable parameters must have strictly the same type as the target method's parameters"}),". The Method Handles lookup API is sensitive to sub-typing and boxing of types. It means that if the method expects an ",(0,i.jsx)(n.code,{children:"Object"}),", the ",(0,i.jsx)(n.code,{children:"Injectable"})," must be an ",(0,i.jsx)(n.code,{children:"Object"}),". If it expects an ",(0,i.jsx)(n.code,{children:"int"}),", you cannot specify an ",(0,i.jsx)(n.code,{children:"Integer"}),". In these cases, you must specify the actual type via ",(0,i.jsx)(n.code,{children:"Injectable#ref(ServiceReference<T>, Class<? super T>)"})," or ",(0,i.jsx)(n.code,{children:"Injectable#value(T, Class<? super T>)"})," to tell RDI that it should look for a supertype. Here's an example to illustrate:","\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'public class A {\n    // ...\n    public A(Object o) {\n        this.o = o;\n    }\n    public A(B b) {\n        throw new RuntimeException("Use the other constructor, thanks");\n    }\n}\n\n// ...\nServiceDescriptor descriptor = ServiceDescriptor.builder(A_REF)\n        .setFactoryMethod(constructor(ref(B_REF, Object.class))) // Add Object.class to specify that you want the first constructor and not the second\n        .build();\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," This is also true for return types of static factories and setters, they must exactly match."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"singletons",children:"Singletons"}),"\n",(0,i.jsx)(n.p,{children:"The service descriptor builder lets you set whether the service should be a singleton or not. If a service is defined as a singleton, the container will always re-use the same instance when the service is requested or injected. Otherwise, it will always create a new instance and the same instance will never be shared."}),"\n",(0,i.jsx)(n.p,{children:"By default, all services will be singletons. If you don't want a service to be a singleton, you can specify it like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"ServiceDescriptor descriptor = ServiceDescriptor.builder(ref)\n        .setSingleton(false)\n        .build();\n"})}),"\n",(0,i.jsx)(n.h2,{id:"circular-dependencies",children:"Circular dependencies"}),"\n",(0,i.jsxs)(n.p,{children:["If you have let's say ",(0,i.jsx)(n.code,{children:"A"})," that depends on itself, or ",(0,i.jsx)(n.code,{children:"A"})," that depends on ",(0,i.jsx)(n.code,{children:"B"})," and ",(0,i.jsx)(n.code,{children:"B"})," that depends on ",(0,i.jsx)(n.code,{children:"A"}),", it is called a ",(0,i.jsx)(n.strong,{children:"circular dependency"}),". If RDI detects a circular dependency in a constructor or a static factory, an exception will be thrown when ",(0,i.jsx)(n.strong,{children:"creating the container"}),". For setters, it is not an issue, as they are invoked ",(0,i.jsx)(n.em,{children:"after"})," instantiating the object. However, if none of the services involved in the cycle are declared as singleton, it will lead to an exception ",(0,i.jsx)(n.strong,{children:"at subscription time"}),", as the container would endlessly create new instance for each service. RDI is able to detect that and throw an exception before it turns into an ",(0,i.jsx)(n.code,{children:"OutOfMemoryError"}),", but keep in mind it can only be detected at subscription time. To avoid the issue, declare your services as singleton whenever possible (which should already be by default), or find an alternative to remove the cycle."]}),"\n",(0,i.jsx)(n.h2,{id:"convenience-methods",children:"Convenience methods"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ServiceDescriptor"})," has a few convenience methods to create a new service descriptor for common scenarios. The first one is if your service does not require any dependency. In this situation you can use ",(0,i.jsx)(n.code,{children:"ServiceDescriptor#standalone(ServiceReference)"})," to create the descriptor directly without using a builder. The ",(0,i.jsx)(n.code,{children:"standalone"})," method exists in another variant with a ",(0,i.jsx)(n.code,{children:"boolean"})," as second argument if you want it not to be a singleton."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8193(e,n,t){t.d(n,{R:()=>c,x:()=>o});var s=t(758);const i={},r=s.createContext(i);function c(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);