"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[775],{3157(e,s,r){r.r(s),r.d(s,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>c,metadata:()=>n,toc:()=>f});const n=JSON.parse('{"id":"service-references","title":"Service References","description":"A service represents a Java object that is managed by the RDI container. In order to define the dependencies between the services, it is necessary to have a way to refer to them in a unique way. In most cases referring to a service by its class is sufficient. In some other cases however, you may want to have more than one (but a finite number of) instances for the same class in your application, possibly with different dependencies. This can be achieved by giving unique identifiers to these instances, which can be a simple name. RDI allows both ways to refer to services.","source":"@site/../docs/service-references.md","sourceDirName":".","slug":"/service-references","permalink":"/rdi/docs/service-references","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Alex1304","lastUpdatedAt":1604361078000,"frontMatter":{"id":"service-references","title":"Service References"},"sidebar":"docs","previous":{"title":"Getting Started","permalink":"/rdi/docs/getting-started"},"next":{"title":"Service Descriptors","permalink":"/rdi/docs/service-descriptors"}}');var i=r(6070),t=r(8193);const c={id:"service-references",title:"Service References"},a=void 0,o={},f=[{value:"Referring to a service by its class",id:"referring-to-a-service-by-its-class",level:2},{value:"Referring to a service by a unique name",id:"referring-to-a-service-by-a-unique-name",level:2},{value:"Reference equality",id:"reference-equality",level:2}];function l(e){const s={code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.strong,{children:"service"})," represents a Java object that is managed by the RDI container. In order to define the dependencies between the services, it is necessary to have a way to refer to them in a unique way. In most cases referring to a service by its class is sufficient. In some other cases however, you may want to have more than one (but a finite number of) instances for the same class in your application, possibly with different dependencies. This can be achieved by giving unique identifiers to these instances, which can be a simple name. RDI allows both ways to refer to services."]}),"\n",(0,i.jsx)(s.h2,{id:"referring-to-a-service-by-its-class",children:"Referring to a service by its class"}),"\n",(0,i.jsxs)(s.p,{children:["The easiest way to define a reference to a service is by using the service class. With RDI it is done via the ",(0,i.jsx)(s.code,{children:"ServiceReference#ofType(Class)"})," method. In this case, the name of the service will be equal to the name of the class as by ",(0,i.jsx)(s.code,{children:"Class#getName()"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-java",children:"ServiceReference<A> ref = ServiceReference.ofType(A.class);\nassertEquals(A.class.getName(), ref.getServiceName());\n"})}),"\n",(0,i.jsx)(s.h2,{id:"referring-to-a-service-by-a-unique-name",children:"Referring to a service by a unique name"}),"\n",(0,i.jsxs)(s.p,{children:["You may as well give a custom name to the reference. This is done via ",(0,i.jsx)(s.code,{children:"ServiceReference#of(String, Class)"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-java",children:'ServiceReference<A> ref1 = ServiceReference.of("a1", A.class);\nServiceReference<A> ref2 = ServiceReference.of("a2", A.class);\n'})}),"\n",(0,i.jsx)(s.h2,{id:"reference-equality",children:"Reference equality"}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"ServiceReference"})," class implements ",(0,i.jsx)(s.code,{children:"equals"})," and ",(0,i.jsx)(s.code,{children:"hashCode"})," on the name field only, meaning that two references with the same name but of different type will be considered equal. As a result the following assertions will all be true:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-java",children:'ServiceReference<A> ref1 = ServiceReference.of("a1", A.class);\nServiceReference<A> ref2 = ServiceReference.of("a2", A.class);\nServiceReference<A> ref3 = ServiceReference.ofType(A.class);\nServiceReference<A> ref4 = ServiceReference.of("foo", A.class);\nServiceReference<B> ref5 = ServiceReference.of("foo", B.class);\n\nassertNotEquals(ref1, ref2);\nassertNotEquals(ref1, ref3);\nassertNotEquals(ref2, ref3);\nassertNotEquals(ref3, ref4);\nassertEquals(ref4, ref5);\n'})})]})}function d(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8193(e,s,r){r.d(s,{R:()=>c,x:()=>a});var n=r(758);const i={},t=n.createContext(i);function c(e){const s=n.useContext(t);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);