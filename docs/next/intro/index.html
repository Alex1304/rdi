<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Introduction to RDI · RDI Documentation</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;img align=&quot;right&quot; src=&quot;/rdi/img/logo.png&quot; width=20% /&gt;"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Introduction to RDI · RDI Documentation"/><meta property="og:type" content="website"/><meta property="og:url" content="https://alex1304.github.io/rdi/"/><meta property="og:description" content="&lt;img align=&quot;right&quot; src=&quot;/rdi/img/logo.png&quot; width=20% /&gt;"/><meta property="og:image" content="https://alex1304.github.io/rdi/img/logo.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://alex1304.github.io/rdi/img/logo.png"/><link rel="shortcut icon" href="/rdi/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/darcula.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/rdi/js/scrollSpy.js"></script><link rel="stylesheet" href="/rdi/css/main.css"/><script src="/rdi/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/rdi/"><img class="logo" src="/rdi/img/logo.png" alt="RDI Documentation"/><h2 class="headerTitleWithLogo">RDI Documentation</h2></a><a href="/rdi/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/rdi/docs/next/intro" target="_self">Docs</a></li><li class=""><a href="https://www.javadoc.io/doc/com.github.alex1304/rdi/latest/index.html" target="_self">API</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Discover RDI</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Discover RDI</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/rdi/docs/next/intro">Introduction</a></li><li class="navListItem"><a class="navItem" href="/rdi/docs/next/getting-started">Getting Started</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Core features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rdi/docs/next/service-references">Service References</a></li><li class="navListItem"><a class="navItem" href="/rdi/docs/next/service-descriptors">Service Descriptors</a></li><li class="navListItem"><a class="navItem" href="/rdi/docs/next/the-container">The Container</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Advanced</h3><ul class=""><li class="navListItem"><a class="navItem" href="/rdi/docs/next/annotation-based-configuration">Annotation-based Configuration</a></li><li class="navListItem"><a class="navItem" href="/rdi/docs/next/debugging">Debugging</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Introduction to RDI</h1></header><article><div><span><p><img align="right" src="/rdi/img/logo.png" width=20% /></p>
<h2><a class="anchor" aria-hidden="true" id="what-is-rdi"></a><a href="#what-is-rdi" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is RDI?</h2>
<p>RDI stands for Reactive Dependency Injection. It is a library allowing to manage the instantiation of beans, services, and any kind of Java object living in your application simply by defining their dependencies. The specificity of RDI is that it fully supports the reactive programming paradigm, as defined by the <a href="https://www.reactive-streams.org/">Reactive Streams specification</a>, allowing to make efficient and non-blocking applications with backpressure handling.</p>
<h2><a class="anchor" aria-hidden="true" id="dependency-injection-in-a-nutshell"></a><a href="#dependency-injection-in-a-nutshell" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dependency injection in a nutshell</h2>
<p>The principle of dependency injection isn't new. The way it works is similar to <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans">Spring's IoC Container</a>, as well as some other frameworks featuring a such mechanism like Quarkus or JSF. Unlike these examples however, RDI isn't a full-fledged framework, but rather a lightweight library 100% focused on dependency injection.</p>
<p>To illustrate how dependency injection operates, consider the following basic classes:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> B b;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">(B b)</span> </span>{
        <span class="hljs-keyword">this</span>.b = b;
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>{
}
</code></pre>
<p>You can see that A needs an instance of B in the constructor. Normally you would do something along these lines:</p>
<pre><code class="hljs css language-java">B b = <span class="hljs-keyword">new</span> B();
A a = <span class="hljs-keyword">new</span> A(b);
<span class="hljs-comment">// use A to do stuff</span>
</code></pre>
<p>We are here instantiating A and B in the same place, but you can imagine B is instantiated elsewhere in the application. As a result, it can turn quite difficult to keep track of the lifecycle and the scope of each object, especially in large apps. Dependency injection naturally comes up as a solution when you want to decouple the initialization part from the core logic of your objects.</p>
<p>With a dependency injection library, getting an instance of A would be like this:</p>
<pre><code class="hljs css language-java">A a = container.get(A<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
</code></pre>
<p><code>container</code> here would be an object that is aware of the existence of A and B class, as well as the details about constructor arguments. With all that information, all you need to do is to ask the container &quot;Hey, can I get an instance of A please?&quot; and it will execute. This approach has many advantages other than centralizing instantiation of objects into one place. You can for example tell the container whether it should always return the same instance of A or instantiate a new one each time the object is requested. If it should return the same instance, that's something you would normally do with a singleton pattern, which can cause issues especially in a case of concurrent access by multiple threads. A container would be able to handle that thread safety aspect for you, preferably in a lock-free manner so that it doesn't degrade the performances of your application.</p>
<h2><a class="anchor" aria-hidden="true" id="overview-of-how-rdi-works"></a><a href="#overview-of-how-rdi-works" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Overview of how RDI works</h2>
<p>The way RDI implements this principle does not differ much from what already exists in terms of dependency injection. As such, RDI comes with the concept of <em>container</em>, the main object that will manage the initialization of all objects in your app and that will take care of injecting the necessary dependencies. Dependencies may be specified in constructor arguments, in setter arguments or in factory methods. For the previous example, configuring a container with RDI would look like this:</p>
<pre><code class="hljs css language-java"><span class="hljs-comment">// Define service references as constants</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ServiceReference&lt;A&gt; A_REF = ServiceReference.ofType(A<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ServiceReference&lt;B&gt; B_REF = ServiceReference.ofType(B<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

<span class="hljs-comment">// Create the config</span>
<span class="hljs-comment">// We register both A and B, and specify that we should inject B in the constructor of A</span>
RdiConfig config = RdiConfig.builder()
        .registerService(ServiceDescriptor.builder(A_REF)
                .setFactoryMethod(FactoryMethod.constructor(Injectable.ref(B_REF)))
                .build())
        .registerService(ServiceDescriptor.standalone(B_REF))
        .build();
<span class="hljs-comment">// Create the container by passing the config</span>
RdiServiceContainer container = RdiServiceContainer.create(config);
<span class="hljs-comment">// Get an instance of A. The dependency injection will operate and A will be ready to use!</span>
A a = container.getService(A_REF).block(); <span class="hljs-comment">// Remember RDI is reactive. Here we block until A is fully created.</span>
</code></pre>
<p>Here is some quick explanation of this code:</p>
<ul>
<li>Objects managed by the RDI container are called <strong>services</strong>. Services are referred to by their <strong>reference</strong>, defining their type and optionally their name (if you want to define more than one service of the same type you may give them unique names, by default it uses the name of the class).</li>
<li>Before creating the container, we need a way to tell it what are the different services available and how to inject the dependencies they may have. This is done via the <code>RdiConfig</code> object, where you register a <strong>descriptor</strong> for each service defining the dependencies to inject.</li>
<li>You then pass the config to create the <strong>container</strong>. Dependency resolution and circular dependency checks are performed at creation time.</li>
<li>Once your container is ready, you may call <code>getService</code> with the reference of the service you want, and it will prepare the instance with all the dependencies injected for you. The particularity here is that it doesn't return the instance directly due to the reactive nature of RDI. To get the instance you must <strong>subscribe</strong> to the reactive stream returned by <code>getService</code> (in this case, it is a <code>Mono</code> from <a href="https://projectreactor.io">Reactor Core</a>, a popular implementation of the <a href="https://www.reactive-streams.org/">Reactive Streams specification</a>). Subscribing is done either via <code>.subscribe(Consumer)</code> (which does not block and invokes the consumer when the object is ready), or via <code>.block()</code> (blocks the program and wait until the object is ready).</li>
</ul>
<p>In the above example we only instantiated objects via public constructors. The most interesting part of RDI is when a service needs to be instantiated with a factory method returning a publisher of it. Let's enrich the <code>B</code> class with the following:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">B</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Mono&lt;B&gt; <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> Mono.fromCallable(B::<span class="hljs-keyword">new</span>);
    }
}
</code></pre>
<p>The <code>create</code> method is a static factory that returns a publisher of <code>B</code> (in this case a <code>Mono</code>, but can be anything implementing <code>org.reactivestreams.Publisher</code>). You can imagine that the factory method performs some webservice call or other reactive task before creating the actual instance of B. RDI is able to handle this kind of factory out of the box. The <code>RdiConfig</code> would now look like this:</p>
<pre><code class="hljs css language-java">RdiConfig config = RdiConfig.builder()
        .registerService(ServiceDescriptor.builder(A_REF)
                .setFactoryMethod(FactoryMethod.constructor(Injectable.ref(B_REF)))
                .build())
        .registerService(ServiceDescriptor.builder(B_REF)
                .setFactoryMethod(FactoryMethod.staticFactory(<span class="hljs-string">"create"</span>, Mono<span class="hljs-class">.<span class="hljs-keyword">class</span>))
                .<span class="hljs-title">build</span>())
        .<span class="hljs-title">build</span>()</span>;
</code></pre>
<p>When requesting an instance of A, the container will first subscribe to the Mono returned by <code>B.create()</code>, and then it will inject the obtained B instance into A before returning A. If you have many services like this in you application, RDI may save you a lot of time assembling the reactive chains to get your service instances.</p>
<p>Since version <code>1.1.0</code>, RDI also supports <a href="/rdi/docs/next/annotation-based-configuration">annotation-based configuration</a> of the container to save even more time.</p>
<p>Ready to get started? Go ahead and move to next section.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2020-11-3</em></div><div class="docs-prevnext"><a class="docs-next button" href="/rdi/docs/next/getting-started"><span>Getting Started</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-is-rdi">What is RDI?</a></li><li><a href="#dependency-injection-in-a-nutshell">Dependency injection in a nutshell</a></li><li><a href="#overview-of-how-rdi-works">Overview of how RDI works</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/rdi/" class="nav-home"><img src="/rdi/img/logo.png" alt="RDI Documentation"/></a><div><h5>Docs</h5><a href="/rdi/docs/en/intro">Introduction</a><a href="https://www.javadoc.io/doc/com.github.alex1304/rdi/latest/index.html">API reference (javadoc)</a></div><div><h5>More</h5><a href="https://github.com/Alex1304/rdi">GitHub</a><a class="github-button" href="https://github.com/Alex1304/rdi" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2020 Alex1304 - Made with Docusaurus</section></footer></div></body></html>